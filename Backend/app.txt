# from fastapi import FastAPI
# from pydantic import BaseModel
# import os
# import google.generativeai as genai
# import requests
# from datetime import datetime
# from typing import Dict, Any
# from fastapi.middleware.cors import CORSMiddleware

# app = FastAPI()

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],  # Replace "*" with your frontend's URL for better security
#     allow_credentials=True,
#     allow_methods=["*"],  # Allow all HTTP methods
#     allow_headers=["*"],  # Allow all headers
# )

# class Filters(BaseModel):
#     harvest: str = "all"
#     soil: str = "all"
#     season: str = "all"
#     irrigation: str = "all"
#     fertilizer: str = "all"
#     pests_diseases: str = "all"
#     state: str = "Uttar Pradesh"
#     district: str = "Lucknow"
#     crop: str = "paddy"

# # Mapping for categorical filters to numerical values for regression (simplified)
# soil_map = {"all": 1, "alluvial": 1, "black": 2, "red": 3, "other": 4}
# season_map = {"all": 1, "kharif": 1, "rabi": 2, "zaid": 3}
# irrigation_map = {"all": 1, "yes": 1, "no": 0}
# fertilizer_map = {"all": 1, "organic": 1, "chemical": 2, "none": 0}
# pests_map = {"all": 0, "none": 0, "mild": 1, "severe": 2}

# # City coordinates for weather (example for some districts in UP)
# city_coords = {
#     "Lucknow": {"lat": 26.8467, "lon": 80.9462},
#     "Kanpur": {"lat": 26.4499, "lon": 80.3319},
#     "Agra": {"lat": 27.1767, "lon": 78.0081},
#     # Add more as needed
# }

# @app.post("/predict_and_recommend")
# def predict_and_recommend(filters: Filters) -> Dict[str, Any]:
#     """
#     Endpoint to generate recommendations using Gemini AI.
#     Fetches real-time weather and market price data.
#     """
#     # Step 1: Fetch current weather using Open-Meteo API (free, no key needed)
#     coords = city_coords.get(filters.district, city_coords["Lucknow"])  # Default to Lucknow
#     weather_url = f"https://api.open-meteo.com/v1/forecast?latitude={coords['lat']}&longitude={coords['lon']}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&timezone=Asia/Kolkata"
#     try:
#         weather_response = requests.get(weather_url)
#         weather_data = weather_response.json()
#         current_temp = weather_data['current_weather']['temperature']
#         daily_max = weather_data['daily']['temperature_2m_max'][0]
#         daily_min = weather_data['daily']['temperature_2m_min'][0]
#         precipitation = weather_data['daily']['precipitation_sum'][0]
#         weather_summary = f"Current temperature: {current_temp}¬∞C. Today's max/min: {daily_max}/{daily_min}¬∞C. Precipitation: {precipitation}mm."
#     except Exception as e:
#         weather_summary = "Unable to fetch weather data. Please check connection."

#     # Step 2: Fetch market price (scrape from agmarknet or use placeholder from recent data)
#     current_date = datetime.now().strftime("%d-%m-%Y")
#     market_url = f"https://agmarknet.gov.in/SearchCmmMkt.aspx?Tx_Commodity=23&Tx_State={filters.state}&Tx_District=0&Tx_Market=0&DateFrom=01-09-2025&DateTo={current_date}&Tx_Trend=0&Tx_CommodityHead=Paddy&Tx_StateHead={filters.state}&Tx_DistrictHead=--Select--&Tx_MarketHead=--Select--"
#     try:
#         market_price = 2350  # Placeholder price
#         market_summary = f"Current market price for {filters.crop} in {filters.state}: ‚Çπ{market_price}/Quintal."
#     except Exception:
#         market_summary = "Unable to fetch market price."

#     # Step 3: Generate AI advice using Gemini
#     genai.configure(api_key="AIzaSyCAC-IaVXi3-K9Q4SfBq5Q0biweeOkqsmM")
#     gemini_model = genai.GenerativeModel("gemini-2.0-flash")  # Or use 'gemini-pro'
#     prompt = f"""
#     Provide expert farming advice for a farmer in {filters.state}, {filters.district}, India.
#     Crop: {filters.crop}
#     Filters: Harvest={filters.harvest}, Soil={filters.soil}, Season={filters.season}, Irrigation={filters.irrigation}, Fertilizer={filters.fertilizer}, Pests/Diseases={filters.pests_diseases}
#     Current weather: {weather_summary}
#     Market price: {market_summary}
#     Include recommendations on soil moisture, watering, insecticides, and any other relevant tips. Make it concise and actionable.
#     """
#     try:
#         response = gemini_model.generate_content(prompt)
#         ai_advice = response.text
#     except Exception as e:
#         ai_advice = "Unable to generate AI advice. Please check Gemini API key."

#     # Step 4: Add fun element
#     fun_fact = "Fun fact: Paddy crops can help in carbon sequestration! Keep farming green! üåæ"

#     # Compile recommendation message
#     recommendation = f"""
#     {ai_advice}

#     Additional Details:
#     - Weather: {weather_summary}
#     - Market Price: {market_summary}

#     {fun_fact}
#     """

#     return {"recommendation": recommendation}

# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=8000)










# ========================================================================================
# from fastapi import FastAPI, HTTPException
# from pydantic import BaseModel
# import google.generativeai as genai
# import requests
# from typing import Dict, Any
# from fastapi.middleware.cors import CORSMiddleware

# app = FastAPI()

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# class Filters(BaseModel):
#     harvest: str = "all"
#     soil: str = "all"
#     season: str = "all"
#     irrigation: str = "all"
#     fertilizer: str = "all"
#     pests_diseases: str = "all"
#     state: str = "Uttar Pradesh"
#     district: str = "Lucknow"
#     crop: str = "paddy"
#     language: str = "en"  # 'hi', 'en', 'or'

# # Language mapping
# LANG_MAP = {
#     "hi": "Hindi",
#     "en": "English",
#     "or": "Odia"
# }

# # Configure Gemini
# genai.configure(api_key="AIzaSyCAC-IaVXi3-K9Q4SfBq5Q0biweeOkqsmM")
# model = genai.GenerativeModel("gemini-1.5-flash")

# @app.post("/predict_and_recommend")
# def predict_and_recommend(filters: Filters) -> Dict[str, Any]:
#     lang_name = LANG_MAP.get(filters.language, "English")

#     # --- Step 1: Get Coordinates using Gemini ---
#     coord_prompt = f"""
#     What are the latitude and longitude of {filters.district}, {filters.state}, India?
#     Respond in JSON format: {{ "lat": value, "lon": value }}.
#     If unsure, give best estimate.
#     """
#     try:
#         coord_response = model.generate_content(coord_prompt)
#         import json
#         coords = json.loads(coord_response.text.strip())
#         lat, lon = coords["lat"], coords["lon"]
#     except Exception as e:
#         # Fallback to Lucknow if Gemini fails
#         lat, lon = 26.8467, 80.9462

#     # --- Step 2: Fetch Real Weather ---
#     weather_url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current_weather=true&daily=temperature_2m_max,precipitation_sum&timezone=Asia/Kolkata"
#     try:
#         weather_res = requests.get(weather_url, timeout=5)
#         w = weather_res.json()
#         temp = w['current_weather']['temperature']
#         humidity = w['current_weather'].get('relative_humidity', 65)
#         rain = w['daily']['precipitation_sum'][0]
#     except:
#         temp, humidity, rain = 28, 65, 12

#     # --- Step 3: Predict Soil Moisture ---
#     soil_prompt = f"""
#     Based on {filters.district}, {filters.state}, temperature {temp}¬∞C, humidity {humidity}%, 
#     soil type {filters.soil}, season {filters.season}, and irrigation {filters.irrigation},
#     estimate soil moisture percentage (0-100%). Respond with only the number.
#     """
#     try:
#         soil_res = model.generate_content(soil_prompt)
#         soil_moisture = float(soil_res.text.strip())
#     except:
#         soil_moisture = 78

#     # --- Step 4: Predict Market Price ---
#     price_prompt = f"""
#     What is the current market price (‚Çπ per quintal) of {filters.crop} in {filters.district}, {filters.state}?
#     Respond with only the number.
#     """
#     try:
#         price_res = model.generate_content(price_prompt)
#         market_price = int(price_res.text.strip())
#     except:
#         market_price = 2350

#     # --- Step 5: Predict Yield Improvement ---
#     yield_prompt = f"""
#     Based on {filters.crop}, soil: {filters.soil}, season: {filters.season}, 
#     irrigation: {filters.irrigation}, fertilizer: {filters.fertilizer}, 
#     pests: {filters.pests_diseases}, predict yield improvement over average as a number (e.g., 25 for 25% increase).
#     """
#     try:
#         yield_res = model.generate_content(yield_prompt)
#         yield_improvement = float(yield_res.text.strip())
#     except:
#         yield_improvement = 25

#     # --- Step 6: Generate 10 AI Suggestions ---
#     ai_prompt = f"""
#     You are an expert farming advisor. For a farmer growing {filters.crop} in {filters.district}, {filters.state},
#     provide exactly 10 concise, actionable bullet point suggestions in {lang_name}.
#     Consider:
#     - Soil: {filters.soil}
#     - Season: {filters.season}
#     - Irrigation: {filters.irrigation}
#     - Fertilizer: {filters.fertilizer}
#     - Pests: {filters.pests_diseases}
#     - Weather: {temp}¬∞C, Humidity: {humidity}%, Rain: {rain}mm
#     - Soil Moisture: {soil_moisture:.1f}%

#     Format:
#     ‚Ä¢ [suggestion 1]
#     ‚Ä¢ [suggestion 2]
#     ...
#     ‚Ä¢ [suggestion 10]

#     Only 10 bullets. No extra text.
#     """

#     try:
#         ai_res = model.generate_content(ai_prompt)
#         suggestions = ai_res.text.strip()
#         bullets = [line.strip() for line in suggestions.split('\n') if line.strip().startswith('‚Ä¢')]
#         if len(bullets) > 10:
#             bullets = bullets[:10]
#         elif len(bullets) < 10:
#             fill_prompt = f"Generate {10 - len(bullets)} more bullet points in {lang_name}."
#             fill_res = model.generate_content(fill_prompt)
#             more = [line.strip() for line in fill_res.text.split('\n') if line.strip().startswith('‚Ä¢')]
#             bullets.extend(more[:10 - len(bullets)])
#         ai_suggestions = '\n'.join(bullets)
#     except:
#         # Fallback per language
#         fallbacks = {
#             "hi": [f"‚Ä¢ {i+1}" for i in range(10)],
#             "en": [f"‚Ä¢ Tip {i+1}" for i in range(10)],
#             "or": [f"‚Ä¢ ‡¨∏‡≠Ç‡¨ö‡¨®‡¨æ {i+1}" for i in range(10)]
#         }
#         ai_suggestions = '\n'.join(fallbacks.get(filters.language, fallbacks["en"]))

#     # --- Step 7: Fun Fact ---
#     fact_prompt = f"Give one fun agricultural fact in {lang_name}. Start with 'Fun fact:'"
#     try:
#         fact_res = model.generate_content(fact_prompt)
#         fun_fact = fact_res.text.strip()
#     except:
#         fun_fact = "Fun fact: Crop rotation can increase yield by up to 25%! üåæ"

#     # --- Final Output ---
#     recommendation = f"""
# {ai_suggestions}

# Additional Details:
# - Weather: {temp}¬∞C, Humidity: {humidity}%, Rain: {rain}mm
# - Soil Moisture: {soil_moisture:.1f}%
# - Market Price: ‚Çπ{market_price}/quintal for {filters.crop}
# - Expected Yield: {abs(yield_improvement):.1f}% {'increase' if yield_improvement > 0 else 'decrease'} from average

# {fun_fact}
# """

#     return {
#         "recommendation": recommendation,
#         "dashboard": {
#             "coordinates": {"lat": lat, "lon": lon},
#             "expected_yield": {
#                 "value": round(yield_improvement),
#                 "trend": "increase" if yield_improvement > 0 else "decrease" if yield_improvement < 0 else "stable"
#             },
#             "soil_moisture": {"value": round(soil_moisture), "unit": "%"},
#             "weather": {
#                 "temperature": temp,
#                 "humidity": humidity,
#                 "rainfall": rain,
#                 "condition": "partly_cloudy"
#             },
#             "market_price": {
#                 "price": market_price,
#                 "currency": "‚Çπ",
#                 "unit": "quintal"
#             }
#         }
#     }



# ========================================Code where the transaltor file is added for better output================================================
# # app.py
# from fastapi import FastAPI, HTTPException
# from pydantic import BaseModel
# import os
# import google.generativeai as genai
# import requests
# from datetime import datetime
# from typing import Dict, Any
# from fastapi.middleware.cors import CORSMiddleware

# # Import translator
# from translator import get_translated_ui_labels

# app = FastAPI()

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# class Filters(BaseModel):
#     harvest: str = "all"
#     soil: str = "all"
#     season: str = "all"
#     irrigation: str = "all"
#     fertilizer: str = "all"
#     pests_diseases: str = "all"
#     state: str = "Uttar Pradesh"
#     district: str = "Lucknow"
#     crop: str = "paddy"
#     language: str = "en"  # 'hi', 'en', 'or'

# # City coordinates (expand as needed)
# city_coords = {
#     "Lucknow": {"lat": 26.8467, "lon": 80.9462},
#     "Kanpur": {"lat": 26.4499, "lon": 80.3319},
#     "Agra": {"lat": 27.1767, "lon": 78.0081},
#     "Bhopal": {"lat": 23.2599, "lon": 77.4122},
#     "Indore": {"lat": 22.7196, "lon": 75.8577},
#     "Jaipur": {"lat": 26.9124, "lon": 75.7877},
#     "Niwari": {"lat": 23.8467, "lon": 78.7533},
# }


# # Configure Gemini
# genai.configure(api_key=os.getenv("GEMINI_API_KEY", "AIzaSyCAC-IaVXi3-K9Q4SfBq5Q0biweeOkqsmM"))
# gemini_model = genai.GenerativeModel("gemini-1.5-flash")

# @app.post("/predict_and_recommend")
# def predict_and_recommend(filters: Filters) -> Dict[str, Any]:
#     lang = filters.language
    
#     # --- Step 1: Get Coordinates ---
#     if filters.district in city_coords:
#         lat, lon = city_coords[filters.district]["lat"], city_coords[filters.district]["lon"]
#     else:
#         # Ask Gemini for coordinates
#         try:
#             coord_prompt = f"Latitude and longitude of {filters.district}, {filters.state}, India as JSON {{'lat': x, 'lon': y}}"
#             coord_response = gemini_model.generate_content(coord_prompt)
#             import json
#             coords = json.loads(coord_response.text)
#             lat, lon = coords["lat"], coords["lon"]
#         except:
#             lat, lon = 26.8467, 80.9462  # Lucknow fallback

#     # --- Step 2: Fetch Weather ---
#     weather_url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current_weather=true&daily=temperature_2m_max,precipitation_sum&timezone=Asia/Kolkata"
#     try:
#         weather_res = requests.get(weather_url, timeout=5)
#         w = weather_res.json()
#         temp = w['current_weather']['temperature']
#         humidity = w['current_weather'].get('relative_humidity', 65)
#         rain = w['daily']['precipitation_sum'][0]
#     except:
#         temp, humidity, rain = 28, 65, 12

#     # --- Step 3: Predict Soil Moisture ---
#     try:
#         soil_prompt = f"Soil moisture % in {filters.district}, {filters.state} with {filters.soil} soil, {filters.irrigation} irrigation, {temp}¬∞C"
#         soil_res = gemini_model.generate_content(soil_prompt)
#         soil_moisture = float(soil_res.text.strip())
#     except:
#         soil_moisture = 78

#     # --- Step 4: Predict Market Price ---
#     try:
#         price_prompt = f"Current market price ‚Çπ/quintal for {filters.crop} in {filters.district}, {filters.state}"
#         price_res = gemini_model.generate_content(price_prompt)
#         market_price = int(price_res.text.strip())
#     except:
#         market_price = 2350

#     # --- Step 5: Predict Yield Improvement ---
#     try:
#         yield_prompt = f"Yield improvement % for {filters.crop} in {filters.state} with {filters.soil} soil, {filters.season} season"
#         yield_res = gemini_model.generate_content(yield_prompt)
#         yield_improvement = float(yield_res.text.strip())
#     except:
#         yield_improvement = 25

#     # --- Step 6: Generate 10 AI Suggestions ---
#     lang_names = {"hi": "Hindi", "en": "English", "or": "Odia"}
#     lang_name = lang_names.get(lang, "English")
    
#     ai_prompt = f"""
#     You are an expert agricultural scientist and field extension officer with 30 years of experience in Indian farming.
#     Provide exactly 10 concise, practical, and actionable bullet point suggestions for a real farmer in {filters.district}, {filters.state}, India.
#     The farmer is growing {filters.crop} with:
#         - Soil: {filters.soil}
#         - Season: {filters.season}
#         - Irrigation: {filters.irrigation}
#         - Fertilizer: {filters.fertilizer}
#         - Pests/Diseases: {filters.pests_diseases}
#         - Weather: Temperature {temp}¬∞C, Humidity {humidity}%, Rainfall {rain}mm

#     Guidelines:
#         1. Use only real, proven, low-cost farming techniques used in India.
#         2. If the farmer's choice is suboptimal (e.g., "Rain Fed" irrigation in dry area), suggest a better alternative (e.g., "Consider drip irrigation").
#         3. Recommend specific inputs: NOT "use fertilizer" ‚Üí "Use vermicompost or cow dung manure"
#         4. Suggest real pest control: NOT "control pests" ‚Üí "Spray neem oil (5 ml per liter) every 7 days"
#         5. Include timing: "Apply irrigation between 6‚Äì8 AM"
#         6. Do NOT use generic tips like "Tip 1", "Good practice", or "Consider options".
#         7. Format:
#             ‚Ä¢ [specific, actionable suggestion]
#             ‚Ä¢ [another real suggestion]
#             ...
#             ‚Ä¢ [10th suggestion] 
#         8. Output ONLY 10 bullet points. No headings, no explanations, no fun facts.
#         9. Language: {lang_name}

#     Example (for poor irrigation):
#         ‚Ä¢ Switch from rain-fed to drip irrigation to save 40% water and increase yield
#         ‚Ä¢ Apply mulch using rice straw to retain soil moisture  
#     """
    
#     try:
#         ai_res = gemini_model.generate_content(ai_prompt)
#         suggestions = "\n".join([
#             line.strip() for line in ai_res.text.split('\n') 
#             if line.strip().startswith('‚Ä¢')
#         ][:10])
#     except:
#         suggestions = "\n‚Ä¢ Tip 1\n‚Ä¢ Tip 2\n‚Ä¢ Tip 3\n‚Ä¢ Tip 4\n‚Ä¢ Tip 5\n‚Ä¢ Tip 6\n‚Ä¢ Tip 7\n‚Ä¢ Tip 8\n‚Ä¢ Tip 9\n‚Ä¢ Tip 10"

#     # --- Step 7: Fun Fact ---
#     try:
#         fact_prompt = f"Fun agricultural fact in {lang_name}"
#         fact_res = gemini_model.generate_content(fact_prompt)
#         fun_fact = fact_res.text.strip()
#     except:
#         fun_fact = "Fun fact: Crop rotation can increase yield by up to 25%! üåæ"

#     # --- Step 8: Get Translated UI Labels ---
#     ui_labels = get_translated_ui_labels(lang)

#     # --- Final Response ---
#     recommendation = f"""
# {suggestions}

# Additional Details:
# - Weather: {temp}¬∞C, Humidity: {humidity}%, Rain: {rain}mm
# - Soil Moisture: {soil_moisture:.1f}%
# - Market Price: ‚Çπ{market_price}/quintal for {filters.crop}
# - Expected Yield: {abs(yield_improvement):.1f}% {'increase' if yield_improvement > 0 else 'decrease'}

# {fun_fact}
# """

#     return {
#         "recommendation": recommendation,
#         "dashboard": {
#             "expected_yield": {
#                 "value": round(yield_improvement),
#                 "trend": "increase" if yield_improvement > 0 else "decrease"
#             },
#             "soil_moisture": {"value": round(soil_moisture), "unit": "%"},
#             "weather": {
#                 "temperature": temp,
#                 "humidity": humidity,
#                 "rainfall": rain,
#                 "condition": "partly_cloudy"
#             },
#             "market_price": {
#                 "price": market_price,
#                 "currency": "‚Çπ",
#                 "unit": "quintal"
#             }
#         },
#         "ui_labels": ui_labels
#     }















































# ======================Getting Output============================
# from fastapi import FastAPI
# import pandas as pd
# from pydantic import BaseModel
# import os
# import requests
# from datetime import datetime
# from typing import Dict, Any, Optional
# from fastapi.middleware.cors import CORSMiddleware
# import geocoder
# import json
# import joblib

# # ------------------ Load ML model ------------------
# ml_model = joblib.load("crop_yield_model.pkl")

# def predict_yield_ml(crop: str, district: str, region: str, irrigation: str, weather_data: Dict) -> float:
#     """Predict yield (tons/ha) using saved ML model."""
#     sample = pd.DataFrame([{
#         "state": region,
#         "district": district,
#         "crop": crop,
#         "irrigation_source": irrigation,
#         "rainfall_mm": weather_data.get("precipitation_sum", 0),
#         "avg_temp_C": weather_data.get("temperature_2m", 0),
#         "soil_ph": 6.5,
#         "soil_organic_carbon_pct": 0.8,
#         "irrigation_pct": 60,
#         "fertilizer_kg_ha": 150
#     }])
#     prediction = ml_model.predict(sample)[0]
#     return round(prediction, 2)

# # ------------------ FastAPI init ------------------
# app = FastAPI()

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],  # Change to frontend URL in production
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# # ------------------ Request Schema ------------------
# class FilterState(BaseModel):
#     cropType: str = ""
#     soilType: str = ""
#     season: str = ""
#     irrigation: str = ""
#     fertilizer: str = ""
#     pestDisease: str = ""
#     region: str = ""
#     district: str = ""
#     budget: str = ""

# # ------------------ Utility functions ------------------
# def get_coordinates(district: str, state: str) -> Optional[Dict[str, float]]:
#     try:
#         location = geocoder.arcgis(f"{district}, {state}, India")
#         if location.ok:
#             return {"lat": location.lat, "lng": location.lng}
#         return None
#     except Exception:
#         return None

# def get_weather_data(lat: float, lng: float) -> Dict[str, Any]:
#     try:
#         url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lng}&current=temperature_2m,relative_humidity_2m,precipitation,weather_code&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&timezone=auto"
#         response = requests.get(url)
#         data = response.json()

#         weather_codes = {
#             0: "Clear sky", 1: "Mainly clear", 2: "Partly cloudy", 3: "Overcast",
#             45: "Fog", 48: "Depositing rime fog", 51: "Light drizzle", 53: "Moderate drizzle",
#             55: "Dense drizzle", 61: "Slight rain", 63: "Moderate rain", 65: "Heavy rain",
#             71: "Slight snow fall", 73: "Moderate snow fall", 75: "Heavy snow fall",
#             80: "Slight rain showers", 81: "Moderate rain showers", 82: "Violent rain showers",
#             95: "Thunderstorm"
#         }

#         current = data.get("current", {})
#         daily = data.get("daily", {})

#         return {
#             "temperature": current.get("temperature_2m", 0),
#             "humidity": current.get("relative_humidity_2m", 0),
#             "precipitation": current.get("precipitation", 0),
#             "weather_condition": weather_codes.get(current.get("weather_code", 0), "Unknown"),
#             "max_temp": daily.get("temperature_2m_max", [0])[0],
#             "min_temp": daily.get("temperature_2m_min", [0])[0],
#             "precipitation_sum": daily.get("precipitation_sum", [0])[0]
#         }
#     except Exception as e:
#         print(f"Weather API error: {e}")
#         return {}

# def get_soil_data(district: str, state: str, crop: str) -> Dict[str, Any]:
#     # Static fallback soil info (so no LLM crash)
#     return {
#         "soil_moisture": 65,
#         "ph_level": 6.5,
#         "nitrogen_level": "medium",
#         "phosphorus_level": "medium",
#         "improvement_suggestions": [
#             "Add organic compost to improve soil structure",
#             "Use cover crops to prevent erosion",
#             "Test soil regularly to monitor nutrient levels"
#         ]
#     }

# def get_market_data(district: str, state: str, crop: str) -> Dict[str, Any]:
#     # Static fallback market info
#     return {
#         "current_price": 2500,
#         "price_trend": "stable",
#         "nearby_districts": [
#             {"name": "District 1", "price": 2450},
#             {"name": "District 2", "price": 2550},
#             {"name": "District 3", "price": 2400},
#             {"name": "District 4", "price": 2600},
#             {"name": "District 5", "price": 2500},
#             {"name": "District 6", "price": 2480}
#         ],
#         "market_trends": [
#             "Demand is steady with normal supply",
#             "Prices expected to remain stable in coming weeks",
#             "Good quality produce fetching premium prices"
#         ]
#     }

# def get_yield_prediction(filters: FilterState, weather_data: Dict, soil_data: Dict) -> Dict[str, Any]:
#     try:
#         ml_yield = predict_yield_ml(
#             filters.cropType,
#             filters.district,
#             filters.region,
#             filters.irrigation,
#             weather_data
#         )
#         return {
#             "expected_yield": ml_yield,
#             "yield_trend": "stable",
#             "best_planting_time": "October to November",
#             "irrigation_schedule": "Every 7-10 days depending on rainfall",
#             "ai_suggestions": [
#                 "Monitor soil moisture regularly",
#                 "Apply balanced fertilizer at right growth stages",
#                 "Implement integrated pest management"
#             ]
#         }
#     except Exception as e:
#         print(f"Yield prediction error: {e}")
#         return {
#             "expected_yield": 75,
#             "yield_trend": "increasing",
#             "best_planting_time": "October to November",
#             "irrigation_schedule": "Every 7-10 days depending on rainfall",
#             "ai_suggestions": [
#                 "Monitor soil moisture regularly",
#                 "Apply balanced fertilizer at right growth stages",
#                 "Implement integrated pest management"
#             ]
#         }

# # ------------------ Routes ------------------
# @app.post("/api/advisory")
# async def get_advisory(filters: FilterState):
#     if not filters.district or not filters.region or not filters.cropType:
#         return {"error": "Please select region, district and crop type to get recommendations"}
    
#     coords = get_coordinates(filters.district, filters.region)
#     if not coords:
#         return {"error": "Could not find location coordinates"}
    
#     weather_data = get_weather_data(coords["lat"], coords["lng"])
#     soil_data = get_soil_data(filters.district, filters.region, filters.cropType)
#     market_data = get_market_data(filters.district, filters.region, filters.cropType)
#     yield_data = get_yield_prediction(filters, weather_data, soil_data)

#     # ‚úÖ Instead of LLM, return safe recommendations
#     recommendations = [
#         "Prepare soil with organic manure before sowing",
#         "Plant at recommended spacing to maximize yield",
#         "Schedule irrigation every 7-10 days depending on rainfall",
#         "Use balanced fertilizer (NPK) at key growth stages",
#         "Apply pest control measures proactively",
#         "Harvest at the right moisture level for best results",
#         "Store produce in dry, ventilated storage",
#         "Monitor local market before selling",
#         "Adopt crop rotation for soil health",
#         "Use weather updates for better planning"
#     ]
    
#     return {
#         "recommendation": "\n".join([f"{i+1}. {r}" for i, r in enumerate(recommendations)]),
#         "weather_data": weather_data,
#         "soil_data": soil_data,
#         "market_data": market_data,
#         "yield_data": yield_data,
#         "timestamp": datetime.now().isoformat()
#     }

# @app.get("/")
# def read_root():
#     return {"message": "Farmer Advisory API is running"}

# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=8000)







# ======================== Good Code for other languages========================
# ==============code with LLM + Prediction========================

# from fastapi import FastAPI
# import pandas as pd
# from pydantic import BaseModel
# import os
# import google.generativeai as genai
# import requests
# from datetime import datetime  # Removed unused import
# from typing import Dict, Any, Optional
# from fastapi.middleware.cors import CORSMiddleware
# import geocoder
# import json
# import joblib

# # Load pre-trained ML model at startup
# ml_model = joblib.load("crop_yield_model.pkl")

# def predict_yield_ml(crop: str, district: str, region: str, irrigation: str, weather_data: Dict) -> float:
#     """Predict yield (tons/ha) using saved ML model."""
#     sample = pd.DataFrame([{
#         "state": region,
#         "district": district,
#         "crop": crop,
#         "irrigation_source": irrigation,
#         "rainfall_mm": weather_data.get("precipitation_sum", 0),  # Get actual rainfall from weather data
#         "avg_temp_C": weather_data.get("temperature_2m", 0),  # Get actual temperature from weather data
#         "soil_ph": 6.5,  # Get actual soil pH from weather data
#         "soil_organic_carbon_pct": 0.8,
#         "irrigation_pct": 60,
#         "fertilizer_kg_ha": 150
#     }])
#     prediction = ml_model.predict(sample)[0]
#     return round(prediction, 2)
    
# app = FastAPI()

# app.add_middleware(
#     CORSMiddleware,
#     allow_origins=["*"],
#     allow_credentials=True,
#     allow_methods=["*"],
#     allow_headers=["*"],
# )

# class FilterState(BaseModel):
#     cropType: str = ""
#     soilType: str = ""
#     season: str = ""
#     irrigation: str = ""
#     fertilizer: str = ""
#     pestDisease: str = ""
#     region: str = ""
#     district: str = ""
#     budget: str = ""
#     language: str = "en"  # Add language field

# genai.configure(api_key=os.getenv("GEMINI_API_KEY", ""))

# def get_coordinates(district: str, state: str) -> Optional[Dict[str, float]]:
#     try:
#         location = geocoder.arcgis(f"{district}, {state}, India")
#         if location.ok:
#             return {"lat": location.lat, "lng": location.lng}
#         return None
#     except Exception:
#         return None

# def get_weather_data(lat: float, lng: float) -> Dict[str, Any]:
#     try:
#         url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lng}&current=temperature_2m,relative_humidity_2m,precipitation,weather_code&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&timezone=auto"
#         response = requests.get(url)
#         data = response.json()
        
#         weather_codes = {
#             0: "Clear sky", 1: "Mainly clear", 2: "Partly cloudy", 3: "Overcast",
#             45: "Fog", 48: "Depositing rime fog", 51: "Light drizzle", 53: "Moderate drizzle",
#             55: "Dense drizzle", 56: "Light freezing drizzle", 57: "Dense freezing drizzle",
#             61: "Slight rain", 63: "Moderate rain", 65: "Heavy rain",
#             66: "Light freezing rain", 67: "Heavy freezing rain", 71: "Slight snow fall",
#             73: "Moderate snow fall", 75: "Heavy snow fall", 77: "Snow grains",
#             80: "Slight rain showers", 81: "Moderate rain showers", 82: "Violent rain showers",
#             85: "Slight snow showers", 86: "Heavy snow showers", 95: "Thunderstorm",
#             96: "Thunderstorm with slight hail", 99: "Thunderstorm with heavy hail"
#         }
        
#         current = data.get("current", {})
#         daily = data.get("daily", {})
        
#         weather_condition = weather_codes.get(current.get("weather_code", 0), "Unknown")
        
#         return {
#             "temperature": current.get("temperature_2m", 0),
#             "humidity": current.get("relative_humidity_2m", 0),
#             "precipitation": current.get("precipitation", 0),
#             "weather_condition": weather_condition,
#             "max_temp": daily.get("temperature_2m_max", [0])[0] if daily.get("temperature_2m_max") else 0,
#             "min_temp": daily.get("temperature_2m_min", [0])[0] if daily.get("temperature_2m_min") else 0,
#             "precipitation_sum": daily.get("precipitation_sum", [0])[0] if daily.get("precipitation_sum") else 0
#         }
#     except Exception as e:
#         print(f"Weather API error: {e}")
#         return {}

# def get_soil_data(district: str, state: str, crop: str, language: str = "en") -> Dict[str, Any]:
#     try:
#         model = genai.GenerativeModel("gemini-1.5-flash")
        
#         # Language-specific prompts
#         if language == "hi":
#             prompt = f"""
#             {district}, {state} ‡§Æ‡•á‡§Ç {crop} ‡§â‡§ó‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡§æ ‡§°‡•á‡§ü‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§
#             ‡§ï‡•á‡§µ‡§≤ JSON ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§Ç ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§Ø‡•á keys ‡§π‡•ã‡§Ç:
#             - soil_moisture (‡§™‡•ç‡§∞‡§§‡§ø‡§∂‡§§ ‡§Æ‡•á‡§Ç)
#             - ph_level (4-9 ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ)
#             - nitrogen_level (text: ‡§ï‡§Æ, ‡§Æ‡§ß‡•ç‡§Ø‡§Æ, ‡§Ö‡§ß‡§ø‡§ï)
#             - phosphorus_level (text: ‡§ï‡§Æ, ‡§Æ‡§ß‡•ç‡§Ø‡§Æ, ‡§Ö‡§ß‡§ø‡§ï)  
#             - improvement_suggestions (3 ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§∏‡•Å‡§ù‡§æ‡§µ‡•ã‡§Ç ‡§ï‡•Ä array)
            
#             ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§î‡§∞ ‡§´‡§∏‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§¨‡§®‡§æ‡§è‡§Ç‡•§ ‡§ï‡•á‡§µ‡§≤ JSON ‡§¶‡•á‡§Ç, ‡§ï‡•ã‡§à ‡§Ö‡§®‡•ç‡§Ø text ‡§®‡§π‡•Ä‡§Ç‡•§
#             """
#         elif language == "or":
#             prompt = f"""
#             {district}, {state}‡¨∞‡≠á {crop} ‡¨ö‡¨æ‡¨∑ ‡¨ï‡¨∞‡¨ø‡¨¨‡¨æ ‡¨™‡¨æ‡¨á‡¨Å ‡¨¨‡¨æ‡¨∏‡≠ç‡¨§‡¨¨‡¨ø‡¨ï ‡¨Æ‡¨æ‡¨ü‡¨ø ‡¨§‡¨•‡≠ç‡≠ü ‡¨™‡≠ç‡¨∞‡¨∏‡≠ç‡¨§‡≠Å‡¨§ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å‡•§
#             ‡¨ï‡≠á‡¨¨‡¨≥ JSON ‡¨∞‡≠á ‡¨â‡¨§‡≠ç‡¨§‡¨∞ ‡¨¶‡¨ø‡¨Ö‡¨®‡≠ç‡¨§‡≠Å ‡¨Ø‡≠á‡¨â‡¨Å‡¨•‡¨ø‡¨∞‡≠á ‡¨è‡¨π‡¨ø keys ‡¨•‡¨ø‡¨¨:
#             - soil_moisture (‡¨∂‡¨§‡¨ï‡¨°‡¨º‡¨æ‡¨∞‡≠á)
#             - ph_level (4-9 ‡¨Æ‡¨ß‡≠ç‡≠ü‡¨∞‡≠á ‡¨∏‡¨Ç‡¨ñ‡≠ç‡≠ü‡¨æ)
#             - nitrogen_level (text: ‡¨ï‡¨Æ‡≠ç, ‡¨Æ‡¨ß‡≠ç‡≠ü‡¨Æ, ‡¨Ö‡¨ß‡¨ø‡¨ï)
#             - phosphorus_level (text: ‡¨ï‡¨Æ‡≠ç, ‡¨Æ‡¨ß‡≠ç‡≠ü‡¨Æ, ‡¨Ö‡¨ß‡¨ø‡¨ï)
#             - improvement_suggestions (3 ‡¨ì‡¨°‡¨º‡¨ø‡¨Ü ‡¨™‡¨∞‡¨æ‡¨Æ‡¨∞‡≠ç‡¨∂‡¨∞ array)
            
#             ‡¨Ö‡¨û‡≠ç‡¨ö‡¨≥ ‡¨è‡¨¨‡¨Ç ‡¨´‡¨∏‡¨≤ ‡¨™‡¨æ‡¨á‡¨Å ‡¨¨‡¨æ‡¨∏‡≠ç‡¨§‡¨¨‡¨ø‡¨ï ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å‡•§ ‡¨ï‡≠á‡¨¨‡¨≥ JSON ‡¨¶‡¨ø‡¨Ö‡¨®‡≠ç‡¨§‡≠Å, ‡¨Ö‡¨®‡≠ç‡≠ü ‡¨ï‡≠å‡¨£‡¨∏‡¨ø text ‡¨®‡¨æ‡¨π‡¨ø‡¨Å‡•§
#             """
#         else:
#             prompt = f"""
#             Generate realistic soil data for {district}, {state} for growing {crop}.
#             Provide only a JSON response with these exact keys:
#             - soil_moisture (percentage)
#             - ph_level (number between 4-9)
#             - nitrogen_level (text: low, medium, high)
#             - phosphorus_level (text: low, medium, high)
#             - improvement_suggestions (array of 3 strings with specific suggestions)
            
#             Make it realistic for the region and crop. Return only JSON, no other text.
#             """
        
#         response = model.generate_content(prompt)
#         json_str = response.text.strip().replace('```json', '').replace('```', '').strip()
#         return json.loads(json_str)
#     except Exception as e:
#         print(f"Soil data generation error: {e}")
#         # Language-specific fallbacks
#         if language == "hi":
#             return {
#                 "soil_moisture": 65,
#                 "ph_level": 6.5,
#                 "nitrogen_level": "‡§Æ‡§ß‡•ç‡§Ø‡§Æ",
#                 "phosphorus_level": "‡§Æ‡§ß‡•ç‡§Ø‡§Æ",
#                 "improvement_suggestions": [
#                     "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§∏‡§Ç‡§∞‡§ö‡§®‡§æ ‡§∏‡•Å‡§ß‡§æ‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ú‡•à‡§µ‡§ø‡§ï ‡§ñ‡§æ‡§¶ ‡§°‡§æ‡§≤‡•á‡§Ç",
#                     "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•á ‡§ï‡§ü‡§æ‡§µ ‡§ï‡•ã ‡§∞‡•ã‡§ï‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ü‡§µ‡§∞‡§£ ‡§´‡§∏‡§≤ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç",
#                     "‡§™‡•ã‡§∑‡§ï ‡§§‡§§‡•ç‡§µ‡•ã‡§Ç ‡§ï‡•Ä ‡§®‡§ø‡§ó‡§∞‡§æ‡§®‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§ï‡§∞‡§æ‡§è‡§Ç"
#                 ]
#             }
#         elif language == "or":
#             return {
#                 "soil_moisture": 65,
#                 "ph_level": 6.5,
#                 "nitrogen_level": "‡¨Æ‡¨ß‡≠ç‡≠ü‡¨Æ",
#                 "phosphorus_level": "‡¨Æ‡¨ß‡≠ç‡≠ü‡¨Æ",
#                 "improvement_suggestions": [
#                     "‡¨Æ‡¨æ‡¨ü‡¨ø‡¨∞ ‡¨ó‡¨†‡¨® ‡¨â‡¨®‡≠ç‡¨®‡¨§ ‡¨ï‡¨∞‡¨ø‡¨¨‡¨æ ‡¨™‡¨æ‡¨á‡¨Å ‡¨ú‡≠à‡¨¨‡¨ø‡¨ï ‡¨ñ‡¨§ ‡¨Æ‡¨ø‡¨∂‡¨æ‡¨®‡≠ç‡¨§‡≠Å",
#                     "‡¨Æ‡¨æ‡¨ü‡¨ø‡¨∞ ‡¨ï‡≠ç‡¨∑‡≠ü ‡¨∞‡≠ã‡¨ï‡¨ø‡¨¨‡¨æ ‡¨™‡¨æ‡¨á‡¨Å ‡¨Ü‡¨ö‡≠ç‡¨õ‡¨æ‡¨¶‡¨® ‡¨´‡¨∏‡¨≤ ‡¨¨‡≠ç‡≠ü‡¨¨‡¨π‡¨æ‡¨∞ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å",
#                     "‡¨™‡≠ã‡¨∑‡¨ï ‡¨§‡¨§‡≠ç‡¨§‡≠ç‡≠± ‡¨®‡¨ø‡¨∞‡≠Ä‡¨ï‡≠ç‡¨∑‡¨£ ‡¨™‡¨æ‡¨á‡¨Å ‡¨®‡¨ø‡≠ü‡¨Æ‡¨ø‡¨§ ‡¨Æ‡¨æ‡¨ü‡¨ø ‡¨™‡¨∞‡≠Ä‡¨ï‡≠ç‡¨∑‡¨æ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å"
#                 ]
#             }
#         else:
#             return {
#                 "soil_moisture": 65,
#                 "ph_level": 6.5,
#                 "nitrogen_level": "medium",
#                 "phosphorus_level": "medium",
#                 "improvement_suggestions": [
#                     "Add organic compost to improve soil structure",
#                     "Use cover crops to prevent erosion",
#                     "Test soil regularly to monitor nutrient levels"
#                 ]
#             }

# def get_market_data(district: str, state: str, crop: str, language: str = "en") -> Dict[str, Any]:
#     try:
#         model = genai.GenerativeModel("gemini-1.5-flash")
        
#         # Language-specific prompts
#         if language == "hi":
#             prompt = f"""
#             {district}, {state} ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§ï‡•á ‡§ú‡§ø‡§≤‡•ã‡§Ç ‡§Æ‡•á‡§Ç {crop} ‡§ï‡§æ ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§¨‡§æ‡§ú‡§æ‡§∞ ‡§°‡•á‡§ü‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§
#             ‡§ï‡•á‡§µ‡§≤ JSON ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§Ç ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§Ø‡•á keys ‡§π‡•ã‡§Ç:
#             - current_price (‚Çπ/‡§ï‡•ç‡§µ‡§ø‡§Ç‡§ü‡§≤ ‡§Æ‡•á‡§Ç ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ)
#             - price_trend (text: ‡§¨‡§¢‡§º ‡§∞‡§π‡§æ, ‡§ò‡§ü ‡§∞‡§π‡§æ, ‡§∏‡•ç‡§•‡§ø‡§∞)
#             - nearby_districts (6 ‡§™‡§æ‡§∏ ‡§ï‡•á ‡§ú‡§ø‡§≤‡•ã‡§Ç ‡§ï‡•Ä array ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç name ‡§î‡§∞ price ‡§π‡•ã)
#             - market_trends (3 ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§¨‡§æ‡§ú‡§æ‡§∞ insights ‡§ï‡•Ä array)
            
#             ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞ ‡§î‡§∞ ‡§´‡§∏‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§µ‡§æ‡§∏‡•ç‡§§‡§µ‡§ø‡§ï ‡§¨‡§®‡§æ‡§è‡§Ç‡•§ ‡§ï‡•á‡§µ‡§≤ JSON ‡§¶‡•á‡§Ç, ‡§ï‡•ã‡§à ‡§Ö‡§®‡•ç‡§Ø text ‡§®‡§π‡•Ä‡§Ç‡•§
#             """
#         elif language == "or":
#             prompt = f"""
#             {district}, {state} ‡¨®‡¨ø‡¨ï‡¨ü‡¨∏‡≠ç‡¨• ‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ‡¨Æ‡¨æ‡¨®‡¨ô‡≠ç‡¨ï‡¨∞‡≠á {crop}‡¨∞ ‡¨¨‡¨æ‡¨∏‡≠ç‡¨§‡¨¨‡¨ø‡¨ï ‡¨¨‡¨ú‡¨æ‡¨∞ ‡¨§‡¨•‡≠ç‡≠ü ‡¨™‡≠ç‡¨∞‡¨∏‡≠ç‡¨§‡≠Å‡¨§ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å‡•§
#             ‡¨ï‡≠á‡¨¨‡¨≥ JSON ‡¨∞‡≠á ‡¨â‡¨§‡≠ç‡¨§‡¨∞ ‡¨¶‡¨ø‡¨Ö‡¨®‡≠ç‡¨§‡≠Å ‡¨Ø‡≠á‡¨â‡¨Å‡¨•‡¨ø‡¨∞‡≠á ‡¨è‡¨π‡¨ø keys ‡¨•‡¨ø‡¨¨:
#             - current_price (‚Çπ/‡¨ï‡≠ç‡≠±‡¨ø‡¨£‡≠ç‡¨ü‡¨æ‡¨≤‡¨∞‡≠á ‡¨∏‡¨Ç‡¨ñ‡≠ç‡≠ü‡¨æ)
#             - price_trend (text: ‡¨¨‡≠É‡¨¶‡≠ç‡¨ß‡¨ø, ‡¨π‡≠ç‡¨∞‡¨æ‡¨∏, ‡¨∏‡≠ç‡¨•‡¨ø‡¨∞)
#             - nearby_districts (6 ‡¨®‡¨ø‡¨ï‡¨ü‡¨∏‡≠ç‡¨• ‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ‡¨∞ array ‡¨Ø‡≠á‡¨â‡¨Å‡¨•‡¨ø‡¨∞‡≠á name ‡¨è‡¨¨‡¨Ç price ‡¨Ö‡¨õ‡¨ø)
#             - market_trends (3 ‡¨ì‡¨°‡¨º‡¨ø‡¨Ü ‡¨¨‡¨ú‡¨æ‡¨∞ insights ‡¨∞ array)
            
#             ‡¨Ö‡¨û‡≠ç‡¨ö‡¨≥ ‡¨è‡¨¨‡¨Ç ‡¨´‡¨∏‡¨≤ ‡¨™‡¨æ‡¨á‡¨Å ‡¨¨‡¨æ‡¨∏‡≠ç‡¨§‡¨¨‡¨ø‡¨ï ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å‡•§ ‡¨ï‡≠á‡¨¨‡¨≥ JSON ‡¨¶‡¨ø‡¨Ö‡¨®‡≠ç‡¨§‡≠Å, ‡¨Ö‡¨®‡≠ç‡≠ü ‡¨ï‡≠å‡¨£‡¨∏‡¨ø text ‡¨®‡¨æ‡¨π‡¨ø‡¨Å‡•§
#             """
#         else:
#             prompt = f"""
#             Generate realistic market data for {crop} in districts near {district}, {state}.
#             Provide only a JSON response with these exact keys:
#             - current_price (number in ‚Çπ/quintal)
#             - price_trend (text: increasing, decreasing, stable)
#             - nearby_districts (array of objects with name and price for 6 nearby districts)
#             - market_trends (array of 3 strings with current market insights)
            
#             Make it realistic for the region and crop. Return only JSON, no other text.
#             """
        
#         response = model.generate_content(
#             prompt,
#             generation_config={"response_mime_type": "application/json"}
#         )
#         return json.loads(response.text)

#     except Exception as e:
#         print(f"Market data generation error: {e}")
#         # Language-specific fallbacks
#         if language == "hi":
#             return {
#                 "current_price": 2500,
#                 "price_trend": "‡§∏‡•ç‡§•‡§ø‡§∞",
#                 "nearby_districts": [
#                     {"name": "‡§ú‡§ø‡§≤‡§æ 1", "price": 2450},
#                     {"name": "‡§ú‡§ø‡§≤‡§æ 2", "price": 2550},
#                     {"name": "‡§ú‡§ø‡§≤‡§æ 3", "price": 2400},
#                     {"name": "‡§ú‡§ø‡§≤‡§æ 4", "price": 2600},
#                     {"name": "‡§ú‡§ø‡§≤‡§æ 5", "price": 2500},
#                     {"name": "‡§ú‡§ø‡§≤‡§æ 6", "price": 2480}
#                 ],
#                 "market_trends": [
#                     "‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§Ü‡§™‡•Ç‡§∞‡•ç‡§§‡§ø ‡§ï‡•á ‡§∏‡§æ‡§• ‡§Æ‡§æ‡§Ç‡§ó ‡§∏‡•ç‡§•‡§ø‡§∞ ‡§π‡•à",
#                     "‡§Ü‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§π‡§´‡•ç‡§§‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§ï‡•Ä‡§Æ‡§§‡•á‡§Ç ‡§∏‡•ç‡§•‡§ø‡§∞ ‡§∞‡§π‡§®‡•á ‡§ï‡•Ä ‡§â‡§Æ‡•ç‡§Æ‡•Ä‡§¶",
#                     "‡§Ö‡§ö‡•ç‡§õ‡•Ä ‡§ó‡•Å‡§£‡§µ‡§§‡•ç‡§§‡§æ ‡§µ‡§æ‡§≤‡•Ä ‡§â‡§™‡§ú ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§ï‡•Ä‡§Æ‡§§ ‡§™‡§∞ ‡§Æ‡§ø‡§≤ ‡§∞‡§π‡•Ä"
#                 ]
#             }
#         elif language == "or":
#             return {
#                 "current_price": 2500,
#                 "price_trend": "‡¨∏‡≠ç‡¨•‡¨ø‡¨∞",
#                 "nearby_districts": [
#                     {"name": "‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ ‡≠ß", "price": 2450},
#                     {"name": "‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ ‡≠®", "price": 2550},
#                     {"name": "‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ ‡≠©", "price": 2400},
#                     {"name": "‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ ‡≠™", "price": 2600},
#                     {"name": "‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ ‡≠´", "price": 2500},
#                     {"name": "‡¨ú‡¨ø‡¨≤‡≠ç‡¨≤‡¨æ ‡≠¨", "price": 2480}
#                 ],
#                 "market_trends": [
#                     "‡¨∏‡¨æ‡¨ß‡¨æ‡¨∞‡¨£ ‡¨Ø‡≠ã‡¨ó‡¨æ‡¨£ ‡¨∏‡¨π‡¨ø‡¨§ ‡¨ö‡¨æ‡¨π‡¨ø‡¨¶‡¨æ ‡¨∏‡≠ç‡¨•‡¨ø‡¨∞ ‡¨Ö‡¨õ‡¨ø",
#                     "‡¨Ü‡¨ó‡¨æ‡¨Æ‡≠Ä ‡¨∏‡¨™‡≠ç‡¨§‡¨æ‡¨π‡¨∞‡≠á ‡¨¶‡¨æ‡¨Æ ‡¨∏‡≠ç‡¨•‡¨ø‡¨∞ ‡¨∞‡¨π‡¨ø‡¨¨‡¨æ‡¨∞ ‡¨Ü‡¨∂‡¨æ",
#                     "‡¨≠‡¨≤ ‡¨ó‡≠Å‡¨£‡¨¨‡¨§‡≠ç‡¨§‡¨æ ‡¨â‡¨§‡≠ç‡¨™‡¨æ‡¨¶‡¨® ‡¨™‡≠ç‡¨∞‡¨ø‡¨Æ‡¨ø‡≠ü‡¨Æ‡≠ç ‡¨¶‡¨æ‡¨Æ‡¨∞‡≠á ‡¨Æ‡¨ø‡¨≥‡≠Å‡¨õ‡¨ø"
#                 ]
#             }
#         else:
#             return {
#                 "current_price": 2500,
#                 "price_trend": "stable",
#                 "nearby_districts": [
#                     {"name": "District 1", "price": 2450},
#                     {"name": "District 2", "price": 2550},
#                     {"name": "District 3", "price": 2400},
#                     {"name": "District 4", "price": 2600},
#                     {"name": "District 5", "price": 2500},
#                     {"name": "District 6", "price": 2480}
#                 ],
#                 "market_trends": [
#                     "Demand is steady with normal supply",
#                     "Prices expected to remain stable in coming weeks",
#                     "Good quality produce fetching premium prices"
#                 ]
#             }

# def get_yield_prediction(filters: FilterState, weather_data: Dict, soil_data: Dict) -> Dict[str, Any]:
#     try:
#         ml_yield = predict_yield_ml(
#             filters.cropType,
#             filters.district,
#             filters.region,
#             filters.irrigation,
#             weather_data
#         )

#         model = genai.GenerativeModel("gemini-1.5-flash")
        
#         # Language-specific prompts
#         if filters.language == "hi":
#             prompt = f"""
#             {filters.district}, {filters.region} ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§ï‡§ø‡§∏‡§æ‡§® {filters.cropType} ‡§â‡§ó‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§
#             ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§®: {ml_yield} ‡§ü‡§®/‡§π‡•á‡§ï‡•ç‡§ü‡•á‡§Ø‡§∞‡•§
#             ‡§Æ‡•å‡§∏‡§Æ: {weather_data}
#             ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä: {soil_data}
#             ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à: {filters.irrigation}

#             ‡§ï‡•á‡§µ‡§≤ JSON ‡§á‡§∏ ‡§∏‡§ü‡•Ä‡§ï ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç:
#             {{
#               "best_planting_time": "string",
#               "irrigation_schedule": "string", 
#               "ai_suggestions": ["string1", "string2", "string3"]
#             }}
#             ‡§∏‡§≠‡•Ä ‡§â‡§§‡•ç‡§§‡§∞ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç‡•§
#             """
#         elif filters.language == "or":
#             prompt = f"""
#             {filters.district}, {filters.region}‡¨∞‡≠á ‡¨ú‡¨£‡≠á ‡¨ï‡≠É‡¨∑‡¨ï {filters.cropType} ‡¨ö‡¨æ‡¨∑ ‡¨ï‡¨∞‡≠Å‡¨õ‡¨®‡≠ç‡¨§‡¨ø‡•§
#             ‡¨Ö‡¨®‡≠Å‡¨Æ‡¨æ‡¨®‡¨ø‡¨§ ‡¨Ö‡¨Æ‡¨≥: {ml_yield} ‡¨ü‡¨®‡≠ç/‡¨π‡≠á‡¨ï‡≠ç‡¨ü‡¨∞‡•§
#             ‡¨™‡¨æ‡¨£‡¨ø‡¨™‡¨æ‡¨ó: {weather_data}
#             ‡¨Æ‡¨æ‡¨ü‡¨ø: {soil_data}
#             ‡¨ú‡¨≥‡¨∏‡≠á‡¨ö‡¨®: {filters.irrigation}

#             ‡¨ï‡≠á‡¨¨‡¨≥ JSON ‡¨è‡¨π‡¨ø ‡¨∏‡¨†‡¨ø‡¨ï‡≠ç ‡¨´‡¨∞‡≠ç‡¨Æ‡¨æ‡¨ü‡¨∞‡≠á ‡¨¶‡¨ø‡¨Ö‡¨®‡≠ç‡¨§‡≠Å:
#             {{
#               "best_planting_time": "string",
#               "irrigation_schedule": "string",
#               "ai_suggestions": ["string1", "string2", "string3"]
#             }}
#             ‡¨∏‡¨Æ‡¨∏‡≠ç‡¨§ ‡¨â‡¨§‡≠ç‡¨§‡¨∞ ‡¨ì‡¨°‡¨º‡¨ø‡¨Ü‡¨∞‡≠á ‡¨¶‡¨ø‡¨Ö‡¨®‡≠ç‡¨§‡≠Å‡•§
#             """
#         else:
#             prompt = f"""
#             A farmer in {filters.district}, {filters.region} is growing {filters.cropType}.
#             Predicted yield: {ml_yield} tons/ha.
#             Weather: {weather_data}
#             Soil: {soil_data}
#             Irrigation: {filters.irrigation}

#             Return ONLY JSON in this exact format:
#             {{
#               "best_planting_time": "string",
#               "irrigation_schedule": "string",
#               "ai_suggestions": ["string1", "string2", "string3"]
#             }}
#             """
        
#         response = model.generate_content(prompt)
#         raw_text = response.text.strip()
#         raw_text = raw_text.replace("```json", "").replace("```", "").strip()

#         try:
#             llm_data = json.loads(raw_text)
#         except Exception:
#             print("‚ö†Ô∏è Bad LLM JSON, falling back.")
#             llm_data = {}

#         # Language-specific fallbacks
#         if filters.language == "hi":
#             fallback_suggestions = [
#                 "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§ï‡•Ä ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§®‡§ø‡§ó‡§∞‡§æ‡§®‡•Ä ‡§ï‡§∞‡•á‡§Ç",
#                 "‡§∏‡§π‡•Ä ‡§µ‡•É‡§¶‡•ç‡§ß‡§ø ‡§ö‡§∞‡§£‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Ç‡§§‡•Å‡§≤‡§ø‡§§ ‡§â‡§∞‡•ç‡§µ‡§∞‡§ï ‡§°‡§æ‡§≤‡•á‡§Ç",
#                 "‡§è‡§ï‡•Ä‡§ï‡•É‡§§ ‡§ï‡•Ä‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§® ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡•á‡§Ç"
#             ]
#             fallback_planting = "‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞ ‡§∏‡•á ‡§®‡§µ‡§Ç‡§¨‡§∞"
#             fallback_irrigation = "‡§µ‡§∞‡•ç‡§∑‡§æ ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§π‡§∞ 7-10 ‡§¶‡§ø‡§®"
#         elif filters.language == "or":
#             fallback_suggestions = [
#                 "‡¨Æ‡¨æ‡¨ü‡¨ø‡¨∞ ‡¨Ü‡¨∞‡≠ç‡¨¶‡≠ç‡¨∞‡¨§‡¨æ ‡¨®‡¨ø‡≠ü‡¨Æ‡¨ø‡¨§ ‡¨®‡¨ø‡¨∞‡≠Ä‡¨ï‡≠ç‡¨∑‡¨£ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å",
#                 "‡¨∏‡¨†‡¨ø‡¨ï‡≠ç ‡¨¨‡≠É‡¨¶‡≠ç‡¨ß‡¨ø ‡¨™‡¨∞‡≠ç‡¨Ø‡≠ç‡≠ü‡¨æ‡≠ü‡¨∞‡≠á ‡¨∏‡¨®‡≠ç‡¨§‡≠Å‡¨≥‡¨ø‡¨§ ‡¨∏‡¨æ‡¨∞ ‡¨™‡≠ç‡¨∞‡≠ü‡≠ã‡¨ó ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å",
#                 "‡¨è‡¨ï‡≠Ä‡¨ï‡≠É‡¨§ ‡¨ï‡≠Ä‡¨ü ‡¨™‡≠ç‡¨∞‡¨¨‡¨®‡≠ç‡¨ß‡¨® ‡¨≤‡¨æ‡¨ó‡≠Å ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å"
#             ]
#             fallback_planting = "‡¨Ö‡¨ï‡≠ç‡¨ü‡≠ã‡¨¨‡¨∞‡¨∞‡≠Å ‡¨®‡¨≠‡≠á‡¨Æ‡≠ç‡¨¨‡¨∞"
#             fallback_irrigation = "‡¨¨‡¨∞‡≠ç‡¨∑‡¨æ ‡¨â‡¨™‡¨∞‡≠á ‡¨®‡¨ø‡¨∞‡≠ç‡¨≠‡¨∞ ‡¨ï‡¨∞‡¨ø ‡¨™‡≠ç‡¨∞‡¨§‡¨ø 7-10 ‡¨¶‡¨ø‡¨®"
#         else:
#             fallback_suggestions = [
#                 "Monitor soil moisture regularly",
#                 "Apply balanced fertilizer at right growth stages",
#                 "Implement integrated pest management"
#             ]
#             fallback_planting = "October to November"
#             fallback_irrigation = "Every 7-10 days depending on rainfall"

#         return {
#             "expected_yield": ml_yield,
#             "yield_trend": "stable",
#             "best_planting_time": llm_data.get("best_planting_time", fallback_planting),
#             "irrigation_schedule": llm_data.get("irrigation_schedule", fallback_irrigation),
#             "ai_suggestions": llm_data.get("ai_suggestions", fallback_suggestions)
#         }

#     except Exception as e:
#         print(f"Yield prediction error: {e}")
#         # Language-specific fallbacks
#         if filters.language == "hi":
#             return {
#                 "expected_yield": 75,
#                 "yield_trend": "‡§¨‡§¢‡§º ‡§∞‡§π‡§æ",
#                 "best_planting_time": "‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞ ‡§∏‡•á ‡§®‡§µ‡§Ç‡§¨‡§∞",
#                 "irrigation_schedule": "‡§µ‡§∞‡•ç‡§∑‡§æ ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§π‡§∞ 7-10 ‡§¶‡§ø‡§®",
#                 "ai_suggestions": [
#                     "‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•Ä ‡§®‡§Æ‡•Ä ‡§ï‡•Ä ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§®‡§ø‡§ó‡§∞‡§æ‡§®‡•Ä ‡§ï‡§∞‡•á‡§Ç",
#                     "‡§∏‡§π‡•Ä ‡§µ‡•É‡§¶‡•ç‡§ß‡§ø ‡§ö‡§∞‡§£‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§∏‡§Ç‡§§‡•Å‡§≤‡§ø‡§§ ‡§â‡§∞‡•ç‡§µ‡§∞‡§ï ‡§°‡§æ‡§≤‡•á‡§Ç",
#                     "‡§è‡§ï‡•Ä‡§ï‡•É‡§§ ‡§ï‡•Ä‡§ü ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§® ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡•á‡§Ç"
#                 ]
#             }
#         elif filters.language == "or":
#             return {
#                 "expected_yield": 75,
#                 "yield_trend": "‡¨¨‡≠É‡¨¶‡≠ç‡¨ß‡¨ø",
#                 "best_planting_time": "‡¨Ö‡¨ï‡≠ç‡¨ü‡≠ã‡¨¨‡¨∞‡¨∞‡≠Å ‡¨®‡¨≠‡≠á‡¨Æ‡≠ç‡¨¨‡¨∞",
#                 "irrigation_schedule": "‡¨¨‡¨∞‡≠ç‡¨∑‡¨æ ‡¨â‡¨™‡¨∞‡≠á ‡¨®‡¨ø‡¨∞‡≠ç‡¨≠‡¨∞ ‡¨ï‡¨∞‡¨ø ‡¨™‡≠ç‡¨∞‡¨§‡¨ø 7-10 ‡¨¶‡¨ø‡¨®",
#                 "ai_suggestions": [
#                     "‡¨Æ‡¨æ‡¨ü‡¨ø‡¨∞ ‡¨Ü‡¨∞‡≠ç‡¨¶‡≠ç‡¨∞‡¨§‡¨æ ‡¨®‡¨ø‡≠ü‡¨Æ‡¨ø‡¨§ ‡¨®‡¨ø‡¨∞‡≠Ä‡¨ï‡≠ç‡¨∑‡¨£ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å",
#                     "‡¨∏‡¨†‡¨ø‡¨ï‡≠ç ‡¨¨‡≠É‡¨¶‡≠ç‡¨ß‡¨ø ‡¨™‡¨∞‡≠ç‡¨Ø‡≠ç‡≠ü‡¨æ‡≠ü‡¨∞‡≠á ‡¨∏‡¨®‡≠ç‡¨§‡≠Å‡¨≥‡¨ø‡¨§ ‡¨∏‡¨æ‡¨∞ ‡¨™‡≠ç‡¨∞‡≠ü‡≠ã‡¨ó ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å",
#                     "‡¨è‡¨ï‡≠Ä‡¨ï‡≠É‡¨§ ‡¨ï‡≠Ä‡¨ü ‡¨™‡≠ç‡¨∞‡¨¨‡¨®‡≠ç‡¨ß‡¨® ‡¨≤‡¨æ‡¨ó‡≠Å ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å"
#                 ]
#             }
#         else:
#             return {
#                 "expected_yield": 75,
#                 "yield_trend": "increasing",
#                 "best_planting_time": "October to November",
#                 "irrigation_schedule": "Every 7-10 days depending on rainfall",
#                 "ai_suggestions": [
#                     "Monitor soil moisture regularly",
#                     "Apply balanced fertilizer at right growth stages",
#                     "Implement integrated pest management"
#                 ]
#             }

# @app.post("/api/advisory")
# async def get_advisory(filters: FilterState):
#     if not filters.district or not filters.region or not filters.cropType:
#         return {"error": "Please select region, district and crop type to get recommendations"}
    
#     coords = get_coordinates(filters.district, filters.region)
#     if not coords:
#         return {"error": "Could not find location coordinates"}
    
#     weather_data = get_weather_data(coords["lat"], coords["lng"])
#     soil_data = get_soil_data(filters.district, filters.region, filters.cropType, filters.language)
#     market_data = get_market_data(filters.district, filters.region, filters.cropType, filters.language)
#     yield_data = get_yield_prediction(filters, weather_data, soil_data)
    
#     try:
#         model = genai.GenerativeModel("gemini-1.5-flash")
        
#         # Language-specific prompts for main recommendation
#         if filters.language == "hi":
#             prompt = f"""
#             ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç, {filters.district}, {filters.region} ‡§Æ‡•á‡§Ç {filters.cropType} ‡§â‡§ó‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§ï‡§ø‡§∏‡§æ‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ 10 ‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü, ‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ‡§®‡•ç‡§µ‡§ø‡§§ ‡§ï‡§∞‡§®‡•á ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§∏‡§ø‡§´‡§æ‡§∞‡§ø‡§∂‡•á‡§Ç ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç:

#             1. ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§§‡•à‡§Ø‡§æ‡§∞‡•Ä: {filters.soilType} ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞
#             2. ‡§¨‡•Å‡§µ‡§æ‡§à ‡§Ö‡§®‡•Å‡§∏‡•Ç‡§ö‡•Ä: {filters.season} ‡§Æ‡•å‡§∏‡§Æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§§‡§Æ ‡§∏‡§Æ‡§Ø
#             3. ‡§∏‡§ø‡§Ç‡§ö‡§æ‡§à: {filters.irrigation} ‡§â‡§™‡§≤‡§¨‡•ç‡§ß‡§§‡§æ ‡§ï‡•á ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤ ‡§µ‡§ø‡§ß‡§ø‡§Ø‡§æ‡§Ç
#             4. ‡§â‡§∞‡•ç‡§µ‡§∞‡•Ä‡§ï‡§∞‡§£: {filters.fertilizer} ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡•ã‡§ú‡§®‡§æ
#             5. ‡§ï‡•Ä‡§ü/‡§∞‡•ã‡§ó ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£: {filters.pestDisease} ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ‡§ì‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∞‡§£‡§®‡•Ä‡§§‡§ø‡§Ø‡§æ‡§Ç
#             6. ‡§Æ‡•å‡§∏‡§Æ ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§®: ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§™‡§∞‡§ø‡§∏‡•ç‡§•‡§ø‡§§‡§ø‡§Ø‡•ã‡§Ç {weather_data} ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó
#             7. ‡§¨‡§ú‡§ü ‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤‡§®: {filters.budget} ‡§¨‡§ú‡§ü ‡§∏‡•ç‡§§‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•ç‡§∞‡§•‡§æ‡§è‡§Ç
#             8. ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§® ‡§∏‡•Å‡§ß‡§æ‡§∞: ‡§â‡§§‡•ç‡§™‡§æ‡§¶‡§® ‡§¨‡§¢‡§º‡§æ‡§®‡•á ‡§ï‡•Ä ‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü ‡§§‡§ï‡§®‡•Ä‡§ï‡•á‡§Ç
#             9. ‡§ï‡§ü‡§æ‡§à: ‡§ï‡§ü‡§æ‡§à ‡§î‡§∞ ‡§ï‡§ü‡§æ‡§à ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§ï‡•Ä ‡§¨‡•á‡§π‡§§‡§∞ ‡§™‡•ç‡§∞‡§•‡§æ‡§è‡§Ç
#             10. ‡§¨‡§æ‡§ú‡§æ‡§∞ ‡§∞‡§£‡§®‡•Ä‡§§‡§ø: {market_data} ‡§∞‡•Å‡§ù‡§æ‡§®‡•ã‡§Ç ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§∏‡§Æ‡§Ø ‡§î‡§∞ ‡§¶‡•É‡§∑‡•ç‡§ü‡§ø‡§ï‡•ã‡§£

#             ‡§ï‡•á‡§µ‡§≤ ‡§∏‡§Ç‡§ï‡•ç‡§∑‡§ø‡§™‡•ç‡§§, ‡§µ‡•ç‡§Ø‡§æ‡§µ‡§π‡§æ‡§∞‡§ø‡§ï ‡§∏‡§≤‡§æ‡§π ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï‡§ø‡§§ ‡§∏‡•Ç‡§ö‡•Ä ‡§™‡•ç‡§∞‡§¶‡§æ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡•á‡§ï ‡§¨‡§ø‡§Ç‡§¶‡•Å ‡§è‡§ï ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§ï‡§æ‡§∞‡•ç‡§Ø ‡§Ü‡§á‡§ü‡§Æ ‡§π‡•ã‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è‡•§ ‡§ï‡•ã‡§à ‡§Ö‡§§‡§ø‡§∞‡§ø‡§ï‡•ç‡§§ ‡§™‡§æ‡§†, ‡§µ‡•ç‡§Ø‡§æ‡§ñ‡•ç‡§Ø‡§æ‡§è‡§Ç, ‡§Ø‡§æ ‡§∏‡•ç‡§µ‡§∞‡•Ç‡§™‡§£ ‡§®‡§π‡•Ä‡§Ç‡•§
#             ‡§∏‡§≠‡•Ä ‡§â‡§§‡•ç‡§§‡§∞ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç‡•§
#             """
#         elif filters.language == "or":
#             prompt = f"""
#             ‡¨ï‡≠É‡¨∑‡¨ø ‡¨¨‡¨ø‡¨∂‡≠á‡¨∑‡¨ú‡≠ç‡¨û ‡¨≠‡¨æ‡¨¨‡≠á, {filters.district}, {filters.region}‡¨∞‡≠á {filters.cropType} ‡¨ö‡¨æ‡¨∑ ‡¨ï‡¨∞‡≠Å‡¨•‡¨ø‡¨¨‡¨æ ‡¨ï‡≠É‡¨∑‡¨ï‡¨ô‡≠ç‡¨ï ‡¨™‡¨æ‡¨á‡¨Å ‡¨∏‡¨†‡¨ø‡¨ï‡≠ç 10‡¨ü‡¨ø ‡¨¨‡¨ø‡¨∂‡≠á‡¨∑, ‡¨ï‡≠ç‡¨∞‡¨ø‡≠ü‡¨æ‡¨®‡≠ç‡¨¨‡≠ü‡¨® ‡¨Ø‡≠ã‡¨ó‡≠ç‡≠ü ‡¨∏‡≠Å‡¨™‡¨æ‡¨∞‡¨ø‡¨∂ ‡¨™‡≠ç‡¨∞‡¨¶‡¨æ‡¨® ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å:

#             1. ‡¨Æ‡¨æ‡¨ü‡¨ø ‡¨™‡≠ç‡¨∞‡¨∏‡≠ç‡¨§‡≠Å‡¨§‡¨ø: {filters.soilType} ‡¨Æ‡¨æ‡¨ü‡¨ø ‡¨™‡≠ç‡¨∞‡¨ï‡¨æ‡¨∞
#             2. ‡¨¨‡≠Ä‡¨ú ‡¨ö‡¨æ‡¨∑ ‡¨∏‡≠Ç‡¨ö‡≠Ä: {filters.season} ‡¨ã‡¨§‡≠Å ‡¨™‡¨æ‡¨á‡¨Å ‡¨â‡¨§‡≠ç‡¨§‡¨Æ ‡¨∏‡¨Æ‡≠ü
#             3. ‡¨ú‡¨≥‡¨∏‡≠á‡¨ö‡¨®: {filters.irrigation} ‡¨â‡¨™‡¨≤‡¨¨‡≠ç‡¨ß‡¨§‡¨æ ‡¨™‡¨æ‡¨á‡¨Å ‡¨â‡¨™‡¨Ø‡≠Å‡¨ï‡≠ç‡¨§ ‡¨™‡¨¶‡≠ç‡¨ß‡¨§‡¨ø
#             4. ‡¨∏‡¨æ‡¨∞ ‡¨™‡≠ç‡¨∞‡≠ü‡≠ã‡¨ó: {filters.fertilizer} ‡¨™‡≠ç‡¨∞‡¨ï‡¨æ‡¨∞ ‡¨™‡¨æ‡¨á‡¨Å ‡¨Ø‡≠ã‡¨ú‡¨®‡¨æ
#             5. ‡¨ï‡≠Ä‡¨ü/‡¨∞‡≠ã‡¨ó ‡¨®‡¨ø‡≠ü‡¨®‡≠ç‡¨§‡≠ç‡¨∞‡¨£: {filters.pestDisease} ‡¨∏‡¨Æ‡¨∏‡≠ç‡≠ü‡¨æ‡¨ó‡≠Å‡¨°‡¨º‡¨ø‡¨ï ‡¨™‡¨æ‡¨á‡¨Å ‡¨∞‡¨£‡¨®‡≠Ä‡¨§‡¨ø
#             6. ‡¨™‡¨æ‡¨£‡¨ø‡¨™‡¨æ‡¨ó ‡¨Ö‡¨®‡≠Å‡¨ï‡≠Ç‡¨≥‡¨®: ‡¨¨‡¨∞‡≠ç‡¨§‡≠ç‡¨§‡¨Æ‡¨æ‡¨® ‡¨™‡¨∞‡¨ø‡¨∏‡≠ç‡¨•‡¨ø‡¨§‡¨ø {weather_data} ‡¨¨‡≠ç‡≠ü‡¨¨‡¨π‡¨æ‡¨∞ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å
#             7. ‡¨¨‡¨ú‡≠á‡¨ü‡≠ç ‡¨Ö‡¨®‡≠Å‡¨ï‡≠Ç‡¨≥‡¨®: {filters.budget} ‡¨¨‡¨ú‡≠á‡¨ü‡≠ç ‡¨∏‡≠ç‡¨§‡¨∞ ‡¨™‡¨æ‡¨á‡¨Å ‡¨™‡¨¶‡≠ç‡¨ß‡¨§‡¨ø
#             8. ‡¨â‡¨§‡≠ç‡¨™‡¨æ‡¨¶‡¨® ‡¨∏‡≠Å‡¨ß‡¨æ‡¨∞: ‡¨â‡¨§‡≠ç‡¨™‡¨æ‡¨¶‡¨® ‡¨¨‡≠É‡¨¶‡≠ç‡¨ß‡¨ø ‡¨™‡¨æ‡¨á‡¨Å ‡¨¨‡¨ø‡¨∂‡≠á‡¨∑ ‡¨™‡¨¶‡≠ç‡¨ß‡¨§‡¨ø
#             9. ‡¨ï‡¨æ‡¨ü‡¨ø‡¨¨‡¨æ: ‡¨ï‡¨æ‡¨ü‡¨ø‡¨¨‡¨æ ‡¨è‡¨¨‡¨Ç ‡¨ï‡¨æ‡¨ü‡¨ø‡¨¨‡¨æ ‡¨™‡¨∞‡≠á ‡¨≠‡¨≤ ‡¨™‡≠ç‡¨∞‡¨•‡¨æ
#             10. ‡¨¨‡¨ú‡¨æ‡¨∞ ‡¨∞‡¨£‡¨®‡≠Ä‡¨§‡¨ø: {market_data} ‡¨™‡≠ç‡¨∞‡¨¨‡≠É‡¨§‡≠ç‡¨§‡¨ø ‡¨â‡¨™‡¨∞‡≠á ‡¨Ü‡¨ß‡¨æ‡¨∞‡¨ø‡¨§ ‡¨∏‡¨Æ‡≠ü ‡¨è‡¨¨‡¨Ç ‡¨™‡≠ç‡¨∞‡¨¨‡≠É‡¨§‡≠ç‡¨§‡¨ø
#             ‡¨ï‡≠á‡¨¨‡¨≥ ‡¨∏‡¨Ç‡¨ï‡≠ç‡¨∑‡¨ø‡¨™‡≠ç‡¨§, ‡¨¨‡≠ç‡≠ü‡¨¨‡¨π‡¨æ‡¨∞‡¨ø‡¨ï ‡¨™‡¨∞‡¨æ‡¨Æ‡¨∞‡≠ç‡¨∂ ‡¨∏‡¨π‡¨ø‡¨§ ‡¨ï‡≠ç‡¨∞‡¨Æ‡¨ø‡¨ï ‡¨§‡¨æ‡¨≤‡¨ø‡¨ï‡¨æ ‡¨™‡≠ç‡¨∞‡¨¶‡¨æ‡¨® ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å‡•§ ‡¨™‡≠ç‡¨∞‡¨§‡≠ç‡≠ü‡≠á‡¨ï ‡¨¨‡¨ø‡¨®‡≠ç‡¨¶‡≠Å ‡¨è‡¨ï ‡¨∏‡≠ç‡¨™‡¨∑‡≠ç‡¨ü ‡¨ï‡¨æ‡¨∞‡≠ç‡¨Ø‡≠ç‡≠ü ‡¨Ü‡¨á‡¨ü‡¨Æ‡≠ç ‡¨π‡≠á‡¨¨‡¨æ ‡¨â‡¨ö‡¨ø‡¨§‡•§ ‡¨ï‡≠å‡¨£‡¨∏‡¨ø ‡¨Ö‡¨§‡¨ø‡¨∞‡¨ø‡¨ï‡≠ç‡¨§ ‡¨™‡¨æ‡¨†‡≠ç‡≠ü, ‡¨¨‡≠ç‡≠ü‡¨æ‡¨ñ‡≠ç‡≠ü‡¨æ, ‡¨ï‡¨ø‡¨Æ‡≠ç‡¨¨‡¨æ ‡¨´‡¨∞‡≠ç‡¨Æ‡¨æ‡¨ü‡¨ø‡¨Ç ‡¨®‡≠Å‡¨π‡≠á‡¨Å‡•§
#             ‡¨∏‡¨Æ‡¨∏‡≠ç‡¨§ ‡¨â‡¨§‡≠ç‡¨§‡¨∞ ‡¨ì‡¨°‡¨º‡¨ø‡¨Ü
#             """
#         else:
#             prompt = f"""
#             As an agricultural expert, provide exactly 10 specific, actionable recommendations for a farmer in {filters.district}, {filters.region} growing {filters.cropType}:

#             1. Soil preparation: {filters.soilType} soil type
#             2. Planting schedule: Optimal timing for {filters.season} season
#             3. Irrigation: Methods suitable for {filters.irrigation} availability
#             4. Fertilization: Plan for {filters.fertilizer} type
#             5. Pest/disease control: Strategies for {filters.pestDisease} issues
#             6. Weather adaptation: Using current conditions {weather_data}
#             7. Budget optimization: Practices for {filters.budget} budget level
#             8. Yield improvement: Specific techniques to increase production
#             9. Harvesting: Best practices for harvesting and post-harvest handling
#             10. Market strategy: Timing and approach based on {market_data} trends

#             Provide only a numbered list with concise, practical advice. Each point should be one clear action item. No additional text, explanations, or formatting.
#             """

#         response = model.generate_content(prompt)
#         recommendation = response.text
#     except Exception as e:
#         recommendation = "Unable to generate AI recommendations at this time. Please try again later."
    
#     return {
#         "recommendation": recommendation,
#         "weather_data": weather_data,
#         "soil_data": soil_data,
#         "market_data": market_data,
#         "yield_data": yield_data,
#         "timestamp": datetime.now().isoformat()  # Removed unused import
#     }
# @app.get("/")
# def read_root():
#     return {"message": "Farmer Advisory API is running"}

# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=8000)























